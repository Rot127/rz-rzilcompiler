{
  "qemu_defined" : [
    "J2_endloop01",
    "J2_endloop1",
    "J2_endloop0"
  ],
  "sub_routines": {
    "extract64": {
      "return_type": "uint64_t",
      "params": ["uint64_t value", "int start", "int length"],
      "code": "{ return (value >> start) & (~0ULL >> (64 - length)); }"
    },
    "sextract64": {
      "return_type": "int64_t",
      "params": ["uint64_t value", "int start", "int length"],
      "code": "{ return ((int32_t)(value << (32 - length - start))) >> (32 - length); }"
    },
    "deposit64": {
      "return_type": "uint64_t",
      "params": ["uint64_t value", "int start", "int length", "uint64_t fieldval"],
      "code": "{ uint64_t mask; mask = (~0U >> (32 - length)) << start; return (value & ~mask) | ((fieldval << start) & mask); }"
    },
    "deposit32": {
      "return_type": "uint32_t",
      "params": ["uint32_t value", "int start", "int length", "uint32_t fieldval"],
      "code": "{ uint32_t mask; mask = (~0U >> (32 - length)) << start; return (value & ~mask) | ((fieldval << start) & mask); }"
    },
    "extract32": {
      "return_type": "uint32_t",
      "params": ["uint32_t value", "int start", "int length"],
      "code": "{ return (value >> start) & (~0U >> (32 - length)); }"
    },
    "fcircadd": {
      "return_type": "int32_t",
      "params": ["HexInsnPktBundle *bundle", "const HexOp *RxV", "int32_t offset", "int32_t M", "int32_t CS"],
      "code": "{ uint32_t K_const = extract32(M, 24, 4); uint32_t length = extract32(M, 0, 17); uint32_t new_ptr = RxV + offset; uint32_t start_addr; uint32_t end_addr; if (K_const == 0 && length >= 4) { start_addr = CS; end_addr = start_addr + length; } else { int32_t mask = (1 << (K_const + 2)) - 1; start_addr = RxV & (~mask); end_addr = start_addr | length; } if (new_ptr >= end_addr) { new_ptr -= length; } else if (new_ptr < start_addr) { new_ptr += length; } RxV = new_ptr; return new_ptr;}"
    },
    "set_c9_jump": {
      "return_type": "void",
      "params": ["HexInsnPktBundle *bundle", "const HexOp *C9_op", "uint32_t target_addr"],
      "code": "{ WRITE_REG(pkt, C9_op, target_addr); JUMP_NO_C9(target_addr); }"
    }
  }
}