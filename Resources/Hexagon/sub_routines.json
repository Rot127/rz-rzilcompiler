{
  "qemu_defined" : [
    "J2_endloop01",
    "J2_endloop1",
    "J2_endloop0"
  ],
  "sub_routines": {
    "extract64": {
      "return_type": "uint64_t",
      "params": ["uint64_t value", "int start", "int length"],
      "code": "{ return (value >> start) & (~0ULL >> (64 - length)); }"
    },
    "sextract64": {
      "return_type": "int64_t",
      "params": ["uint64_t value", "int start", "int length"],
      "code": "{ return ((int32_t)(value << (32 - length - start))) >> (32 - length); }"
    },
    "deposit64": {
      "return_type": "uint64_t",
      "params": ["uint64_t value", "int start", "int length", "uint64_t fieldval"],
      "code": "{ uint64_t mask; mask = (~0U >> (32 - length)) << start; return (value & ~mask) | ((fieldval << start) & mask); }"
    },
    "deposit32": {
      "return_type": "uint32_t",
      "params": ["uint32_t value", "int start", "int length", "uint32_t fieldval"],
      "code": "{ uint32_t mask; mask = (~0U >> (32 - length)) << start; return (value & ~mask) | ((fieldval << start) & mask); }"
    },
    "extract32": {
      "return_type": "uint32_t",
      "params": ["uint32_t value", "int start", "int length"],
      "code": "{ return (value >> start) & (~0U >> (32 - length)); }"
    },
    "fcirc_add": {
      "return_type": "int32_t",
      "params": ["HexInsnPktBundle *bundle", "const HexOp *RxV", "int32_t offset", "int32_t M", "int32_t CS"],
      "code": "{ uint32_t K_const = extract32(M, 24, 4); uint32_t length = extract32(M, 0, 17); uint32_t new_ptr = RxV + offset; uint32_t start_addr; uint32_t end_addr; if (K_const == 0 && length >= 4) { start_addr = CS; end_addr = start_addr + length; } else { int32_t mask = (1 << (K_const + 2)) - 1; start_addr = RxV & (~mask); end_addr = start_addr | length; } if (new_ptr >= end_addr) { new_ptr -= length; } else if (new_ptr < start_addr) { new_ptr += length; } RxV = new_ptr; return new_ptr;}"
    },
    "trap": {
      "return_type": "void",
      "params": ["int32_t trap_type", "uint32_t imm"],
      "code": "{ __NOP; }"
    },
    "clz32": {
      "return_type": "uint32_t",
      "params": ["uint32_t t"],
      "code": "{ uint32_t x = t; if (x == 0) { return 32; } uint32_t n = 0; if (x <= 0x0000ffffu) { n += 16; x <<= 16; } if (x <= 0x00ffffffu) { n += 8; x <<= 8; } if (x <= 0x0fffffffu) { n += 4; x <<= 4; } if (x <= 0x3fffffffu) { n += 2; x <<= 2; } if (x <= 0x7fffffffu) { n++; } return n; }"
    },
    "clz64": {
      "return_type": "uint64_t",
      "params": ["uint64_t t"],
      "code": "{ uint64_t x = t; if (x == 0) { return 64; } uint64_t n = 0; if (x <= 0x00000000ffffffffull) { n += 32; x <<= 32; } if (x <= 0x0000ffffffffffffull) { n += 16; x <<= 16; } if (x <= 0x00ffffffffffffffull) { n += 8; x <<= 8; } if (x <= 0x0fffffffffffffffull) { n += 4; x <<= 4; } if (x <= 0x3fffffffffffffffull) { n += 2; x <<= 2; } if (x <= 0x7fffffffffffffffull) { n++; } return n; }"
    },
    "clo32": {
      "return_type": "uint32_t",
      "params": ["uint32_t x"],
      "code": "{ return clz32(~x); }"
    },
    "clo64": {
      "return_type": "uint64_t",
      "params": ["uint64_t x"],
      "code": "{ return clz64(~x); }"
    },
    "bswap16": {
      "return_type": "uint16_t",
      "params": ["uint16_t t"],
      "code": "{ return ((t & 0xff00) >> 8) | ((t & 0x00ff) << 8); }"
    },
    "bswap32": {
      "return_type": "uint32_t",
      "params": ["uint32_t t"],
      "code": "{ return (((t & 0x000000ff) << 24) | ((t & 0x0000ff00) << 8) | ((t & 0x00ff0000) >> 8) | ((t & 0xff000000) >> 24)); }"
    },
    "bswap64": {
      "return_type": "uint64_t",
      "params": ["uint64_t t"],
      "code": "{ return ( ((t & 0x00000000000000ffull) << 56) | ((t & 0x000000000000ff00ull) << 40) | ((t & 0x0000000000ff0000ull) << 24) | ((t & 0x00000000ff000000ull) << 8) | ((t & 0x000000ff00000000ull) >> 8) | ((t & 0x0000ff0000000000ull) >> 24) | ((t & 0x00ff000000000000ull) >> 40) | ((t & 0xff00000000000000ull) >> 56) ); }"
    },
    "revbit16": {
      "return_type": "uint16_t",
      "params": ["uint16_t t"],
      "code": "{ uint16_t x = bswap16(t); x = ((x & 0xf0f0) >> 4) | ((x & 0x0f0f) << 4); x = ((x & 0x8888) >> 3) | ((x & 0x4444) >> 1) | ((x & 0x2222) << 1) | ((x & 0x1111) << 3); return x; }"
    },
    "revbit32": {
      "return_type": "uint32_t",
      "params": ["uint32_t t"],
      "code": "{ uint32_t x = bswap32(t); x = ((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4); x = ((x & 0x88888888u) >> 3) | ((x & 0x44444444u) >> 1) | ((x & 0x22222222u) << 1) | ((x & 0x11111111u) << 3); return x; }"
    },
    "revbit64": {
      "return_type": "uint64_t",
      "params": ["uint64_t t"],
      "code": "{ uint64_t x = bswap64(t); x = ((x & 0xf0f0f0f0f0f0f0f0ull) >> 4) | ((x & 0x0f0f0f0f0f0f0f0full) << 4); x = ((x & 0x8888888888888888ull) >> 3) | ((x & 0x4444444444444444ull) >> 1) | ((x & 0x2222222222222222ull) << 1) | ((x & 0x1111111111111111ull) << 3); return x; }"
    },
    "fbrev": {
      "return_type": "uint32_t",
      "params": ["uint32_t addr"],
      "code": "{ return deposit32(addr, 0, 16, revbit16(addr)); }"
    }
  }
}