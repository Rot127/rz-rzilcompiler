{
  "qemu_defined" : [
    "J2_endloop01",
    "J2_endloop1",
    "J2_endloop0"
  ],
  "sub_routines": {
    "extract64": {
      "return_type": "uint64_t",
      "params": ["uint64_t value", "int start", "int length"],
      "code": "{ return (value >> start) & (~0ULL >> (64 - length)); }"
    },
    "sextract64": {
      "return_type": "int64_t",
      "params": ["uint64_t value", "int start", "int length"],
      "code": "{ return ((int32_t)(value << (32 - length - start))) >> (32 - length); }"
    },
    "deposit64": {
      "return_type": "uint64_t",
      "params": ["uint64_t value", "int start", "int length", "uint64_t fieldval"],
      "code": "{ uint64_t mask; mask = (~0U >> (32 - length)) << start; return (value & ~mask) | ((fieldval << start) & mask); }"
    },
    "deposit32": {
      "return_type": "uint32_t",
      "params": ["uint32_t value", "int start", "int length", "uint32_t fieldval"],
      "code": "{ uint32_t mask; mask = (~0U >> (32 - length)) << start; return (value & ~mask) | ((fieldval << start) & mask); }"
    },
    "extract32": {
      "return_type": "uint32_t",
      "params": ["uint32_t value", "int start", "int length"],
      "code": "{ return (value >> start) & (~0U >> (32 - length)); }"
    },
    "fcircadd": {
      "return_type": "int32_t",
      "params": ["HexInsnPktBundle *bundle", "const HexOp *RxV", "int32_t offset", "int32_t M", "int32_t CS"],
      "code": "{ uint32_t K_const = extract32(M, 24, 4); uint32_t length = extract32(M, 0, 17); uint32_t new_ptr = RxV + offset; uint32_t start_addr; uint32_t end_addr; if (K_const == 0 && length >= 4) { start_addr = CS; end_addr = start_addr + length; } else { int32_t mask = (1 << (K_const + 2)) - 1; start_addr = RxV & (~mask); end_addr = start_addr | length; } if (new_ptr >= end_addr) { new_ptr -= length; } else if (new_ptr < start_addr) { new_ptr += length; } RxV = new_ptr; return new_ptr;}"
    },
    "trap": {
      "return_type": "void",
      "params": ["int32_t trap_type", "uint32_t imm"],
      "code": "{ __NOP ;}"
    },
    "clz32": {
      "return_type": "uint32_t",
      "params": ["uint32_t t"],
      "code": "{ uint32_t x = t; if (x == 0) { return 32; } uint32_t n = 0; if (x <= 0x0000ffff) { n += 16; x <<= 16; } if (x <= 0x00ffffff) { n += 8; x <<= 8; } if (x <= 0x0fffffff) { n += 4; x <<= 4; } if (x <= 0x3fffffff) { n += 2; x <<= 2; } if (x <= 0x7fffffff) { n++; } return n; }"
    },
    "clz64": {
      "return_type": "uint64_t",
      "params": ["uint64_t t"],
      "code": "{ uint64_t x = t; if (x == 0) { return 64; } uint64_t n = 0; if (x <= 0x00000000ffffffff) { n += 32; x <<= 32; } if (x <= 0x0000ffffffffffff) { n += 16; x <<= 16; } if (x <= 0x00ffffffffffffff) { n += 8; x <<= 8; } if (x <= 0x0fffffffffffffff) { n += 4; x <<= 4; } if (x <= 0x3fffffffffffffff) { n += 2; x <<= 2; } if (x <= 0x7fffffffffffffff) { n++; } return n; }"
    },
    "clo32": {
      "return_type": "uint32_t",
      "params": ["uint32_t x"],
      "code": "{ return clz32(~x); }"
    },
    "clo64": {
      "return_type": "uint64_t",
      "params": ["uint64_t x"],
      "code": "{ return clz64(~x); }"
    }
  }
}